---
title: Hybrid State Management Strategies
description: Hybrid State Management Strategies
---

## Introduction to Hybrid State

Hybrid state management involves a combination of server state and client state to create efficient, scalable, and performant frontend applications.
It leverages the strengths of both approaches, ensuring seamless data synchronization and optimal user experiences.

**Client State**

Client state refers to data that resides on the client side of an application

| **State Type**    | **Scope**                | **Example**                                      |
| ----------------- | ------------------------ | ------------------------------------------------ |
| **UI State**      | Localized, per component | Modal open/close, hover state, active tabs       |
| **Global State**  | Shared across components | User authentication, theme, notifications        |
| **Derived State** | Calculated, not stored   | Filtered lists, computed totals, isAuthenticated |

**Server State**

Server state refers to data that come from external source such as an API or database.
This data is typically changes over times and shared between clients.

---

## Key Principles of Performance in Hybrid State Management

### Minimizing State Redundancy and Overfetching

State redundant and excessive network requests can significantly degrade application performance. Hybrid state management must prioritize strategies that:

- **Avoid Duplicate State**: ensure that the same piece of data is not stored in both server state and client state unless absolutely necessary. Use derived state techniques to compute values dynamically when possible.
  For example, you can use a selector in a state management library to derive filtered results rather than storing multiple filtered versions of the data.

```jsx
function Posts() {
  const [posts, setPosts] = useState([])
  // Drived state for liked posts
  const likedPost = useMemo(() => posts.filter(post => post.liked))

  useEffect(() => {
    async function fetchPosts() {
      const res = await fetch("https://some-endpoint/posts")
      const data = await res.json()
      setPosts(data)
    }
    fetchPosts()
  }, [])

  return <div>Display Posts, liked posts</div>
}
```

- **Leverage Cache for Server State**: using caching mechanisms (e.g., React Query or SWR) to reduce the frequency of fetching data from the server. Proper cache configuration can minimize server load and improve user experience.
  For example, React Query's `useQuery` hook allows you to set a stale time, ensuring that data is fetched only when it becomes outdated, reducing unnecessary network calls.

- **Optimize Fetching Strategies**: employ techniques such as conditional fetching, polling with exponential backoff, and stale-while-revalidate to fetch only what is needed, when it is needed.
  `React query` provides these strategies, allowing you to customize data fetching strategies based on your application's requirements.

- **Normalize Data Structures**: maintain a normalized structure for client state to make updates more simpler and efficient.

```jsx
// The post data received from the API
const state = {
  posts: [
    {
      id: 1,
      title: "Post 1",
      content: "This is post 1",
      user: {
        id: 1,
        name: "Frank 1"
      }
    },
    {
      id: 2,
      title: "Post 2",
      content: "This is post 2",
      user: {
        id: 2,
        name: "Frank 2"
      }
    }
  ]
}

// Normalized state structure
const normalizedState = {
  posts: {
    byId: {
      1: { id: 1, title: "Post 1", content: "This is post 1", userId: 1 },
      2: { id: 2, title: "Post 2", content: "This is post 2", userId: 2 }
    },
    allIds: [1, 2]
  },
  users: {
    byId: {
      1: { id: 1, name: "Frank 1" },
      2: { id: 2, name: "Frank 2" }
    },
    allIds: [1, 2]
  }
}
```

### Reducing UI Renders Complexity by Efficient State Structure

Frequent and unnecessary UI renders can lead to poor performance and a suboptimal user experience. To address this:

- **Split State Appropriately**: Separate states based on their usage and impact to avoid updating unrelated components.
  Using `useState` for managing a dropdown's open/close state while using a global context for user authentication status.
- **Selective Rendering:** Use techniques like React's `memo` or `useMemo` to prevent rerenders for components whose props or state havenâ€™t changed.
  For instance, wrap a list item component with `memo` so that it only rerenders when its specific data changes.
- **Batch State Updates**: Group related state updates into a single operation to minimize renders.

  ```tsx
  type UserData = {
    name: string
    email: string
  }

  function UpdateUserInfo({ id }: { id: string }) {
    const [formState, setFormState] = useState<UserData>()

    useEffect(() => {
      async function fetchUser(id: string) {
        const res = await fetch(`https://some-endpoint/users/${id}`)
        const data = (await res.json()) as UserData
        setFormState(data)
      }
      fetchUser(id)
    }, [id])

    const handleInfoChange = (key: typeof UserData, value: string) => {
      // Batch state updates by merging changes into the single state object
      setFormState(prev => ({
        ...prev,
        [field]: value
      }))
    }

    const handleSubmit = () => {
      console.log("Submit:", formState)
    }

    return (
      <div>
        <input
          type="text"
          placeholder="Name"
          value={formState.name}
          onChange={e => handleInputChange("name", e.target.value)}
        />
        <input
          type="email"
          placeholder="Email"
          value={formState.email}
          onChange={e => handleInputChange("email", e.target.value)}
        />
        <input
          type="password"
          placeholder="Password"
          value={formState.password}
          onChange={e => handleInputChange("password", e.target.value)}
        />
        <button onClick={handleSubmit}>Submit</button>
      </div>
    )
  }
  ```

  Instead of separate each input value into individual state, all fields (name, email, and password) are stored in a single state object.

- **Efficient List Rendering**: For large lists, implement virtualization (e.g., react-window, react-virtualized) to only render items visible in the viewport.

---

### Managing Local and Global State

- Use Local State for Component-Specific Data
- Leverage React Context Sparingly
- Split State Across Components

### Minimizing Re-renders and Optimizing Component Rendering

- Split State Across Components
- Use Memoization for Expensive Computations
- 

### Consider Server-Side Rendering

Server-Side Rendering (SSR) is a technique where an application's HTML is generated on the server and sent to the client, rather than relying on client-side JavaScript to render the UI.
Use frameworks like Next.js for server-side rendering to boost initial page load speed. Using SSR can reduce state management on the client, make it more simpler to handle.

**Initial State Hydration**

In SSR, the server renders the initial HTML and often provides a serialized version of the initial application state. This state is sent to the client and "hydrated" to make the application interactive.

The hydration process involves attaching event listeners to the already-rendered HTML on the client.

**Data Fetching and Preloading**

The server must fetch and preload all necessary data before rendering the application.
This data is included in the HTML payload sent to the client, so the client has all the required information without additional requests.

**Benefits of SSR for State Management**

1. Improved Performance

- The server renders the initial HTML, allowing the user to see content faster, even before JavaScript is fully loaded.
- Reduces the time to the first meaningful paint

2. SEO Optimization

- Search engines can crawl and index the fully rendered HTML, improving search engine rankings.

3. Initial State Consistency

- The server provides a consistent initial state, reducing the risk of mismatch between the server-rendered HTML and the client-rendered React tree.

```jsx
// A Server Component
export default async function PostsPage() {
  const posts = await fetchPosts() // Fetch data on the server
  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {posts.map(post => (
          <li key={post.id}>
            <strong>{post.title}</strong>
            <p>{post.body}</p>
          </li>
        ))}
      </ul>
    </div>
  )
}

async function fetchPosts() {
  const response = await fetch("https://example.com/posts")
  return response.json()
}
```

This is an example of server component using **Next.js 14**. In this component, no client-side JavaScript is needed for this page, improving performance and reducing bunlde size.

---

## Best Practices for Hybrid State Management

### Leverage Zustand with Context API

- Use Zustand + Context to provide a way to create initial data without render

### State Synchronization Between Server and Client with Zustand

### Zustand with React Query

- Optimistic update: Zustand + React Query

## Conclusion

## References

https://tkdodo.eu/blog/zustand-and-react-context